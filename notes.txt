Unit 5.1: Code Generation

learning about how to compile code is important because it gives people a deeper understanding of what takes place when they are running their code.
	Bonus: It also gives me extra thoughts when I'm bored about how to parse Java, Python, Javascript, and even HTML.

Roadmap: Jack program runs through Jack Compiler and turns into VM code
Jack Compiler: in the past, we only had the syntax analyzer with the tokenizer and the parser or the Compilation Engine. Now we need the code generator or CG.
XML is no longer relevant.

Parser is partially rewritten, Code Generator is built from the ground up.

try to simplify complicated coding tasks.
	Simplification 1: Each file is its own class and deserves its own compiler.
	Simplification 2: You only need to compile the declaration of the class, then one subroutine at a time.

What does one see in a subroutine?
	Variables
	Expressions
	Flow of Control
	Objects
	Arrays

	We need to handle all of these. One unit is dedicated to each challenge.
	...well except for objects.

High-level languages are very advanced and complicated with lots of semantics.
VM is very simple. No classes, no subroutines, just a stream of commands.

Learn how to implement procedural code, arrays, and objects.
Techniques: Parsing, Recursive compilation, Code generation, Symbol tables, and Memory management (very lightly touched on here)

Next up: handling variables.



Unit 5.2: Handling Variables

sum = x * (1 + rate)
stream of VM code is generated after compilation.
let's only focus on variables.

to generate VM code, we need to know the virtual segments each variable is in.
handle class-level and subroutine-level variables

each variable has a name, type, kind or role and a scope.
more specifically, an identifier, an int/char/boolean/classname, a field/static/local/argument, and a class-level or subroutine-level scope.

variable properties are needed for code generation, and can be managed efficiently with a symbol table. (hey that's like in the assembler!)

sample code:
class Point {
	field int x, y;
	static int pointCount;

	method int distance(Point other) {
	var int dx, dy;
	let dx = x - other.getx();
	let dy = y - other.gety();
	return Math.sqrt((d*dx)+ (dy*dy));
	}
}

class-level variables with columns name, type, kind, and # of its kind

subroutine has this, then its vars

class-level symbol table is reset every time we compile a new class
subroutine symbol tables are reset every compiling of a subroutine call
codeWriter will not write anything during var dec. write only during var handling


general observations: vary in terms of var types, kinds, and scoping
they can be modified to handle variable compilation in other languages

Now that we know how to handle variables, we can move onto handling expressions!



Unit 5.3: Handling Expressions

infix example: a * (b + c)
prefix example: *a +bc
postfix: a b c + *

stack language is very postfix-oriented

source code: x + g(2,y,-z) * 5
generate parse tree, then generate stack machine code.

from project 10, we get XML. now, in project 11, we need VM.
VM doesn't have operator priority. the compiler ignores this.
some students will ignore operator priority, others won't and will implement it.
both approaches are fine.

parentheses are to be respected, so the compiler will handle them. However, there is otherwise no operator priority.



Unit 5.4: Handling Flow of Control

if statements:
negate the expression, then goto L1 or L2
labels are generated by the compiler

while statements:
negate expression, if it's true execute something else, otherwise execute the statements
labels are, again, generated by the compiler

there are some complications:
	a program usually contains a lot of if and while statements.
		Solution: the compiler can generate unique labels.
	if and while statements may be nested. telescopic code!
		Solution: we already took care of it with recursive compilation.

variables + expressions + flow of control = compiler for simple procedural language!
	...but we still need to handle arrays and objects
a lot of the compiler is done in the parsing
because we already finished the previous tiers of the cake, we don't need to think about how we got it. we just move onto the next cake tier and make a great birthday party, because it's Mommy's birthday today.



Unit 5.5: Handling Objects: Low-Level Aspects

VM doesn't handle objects, as they only have virtual memory segments
it is even worse in low-level machine programs!
the challenge is to bridge the big gaps

first five entries hold stack pointer, local pointer, argument pointer, this pointer, and that pointer
there is a special place called the stack
local and argument variables are located on the stack, managed by VM translator

the heap handles object and array data
you might have many vars on the heap!
we need to use THIS and THAT, but first use pointer segment
managed by VM code

access RAM words 8000 onward
first anchor THIS
then access THIS i
this is the basic technique for accessing object and array data
first anchor using pointer



Unit 5.6: Handling Objects: Construction

the compiler doesn't care about the objects
initialize a class variable as a location on the stack.
when let statement is used, initialize p1 as location of the stack on the heap
what happens when there are multiple classes?

only update relevant symbol table when vars are handled
all we need to do is call the constructor!
the caller needs the constructor to allocate space for itself
pop base address of the new object
what about the impact?

during compile-time, the compiler maps p1v, p2, and d on local 0, 1, and 2
only during runtime go to work do we allocate space on RAM
A constructor typically arranges creation of new objects and initializes it to an initial state, so it needs access to the object's fields
The constructor's code can access the object's data using the THIS segment!
however, we need to anchor the THIS segment with pointer
for fields and statics, make class-level symbol table update
we should find a free memory block on the RAM equal to the number of vars needed
provide alloc with a number, and it will find a block of empty code of the number's length. implemented in OS
align this with the base address of memory.alloc

every jack compiler returns this, so push pointer 0 and return

for code block:
"
constructor Point new(int ax,
					  int ay) {
  let x = ax;
  let y = ay;
  let pointCount = pointCount + 1;
  return this;
}
"

you get:

"
push constant 2
call Memory.alloc 1
pop pointer 0

// let x = ax; let y = ay;
push argument 0
pop this 0
push argument 1
pop this 1

// let pointCount = pointCount + 1;
push static 0
push constant 1
add
pop static 0

// return this
push pointer 0
return

"



5.7: Handling Objects: Manipulation

how to compile methods?
you need to rewrite the OO method calls in a procedural style
this is why you always need self as an argument, because you pass it in during the call!

example:
	"obj.foo(x1, x2, ..)"
	translated (approximately) into:
		"
		push obj
		push x1
		push x2
		push ...
		call foo
		"
caller's code:
"let d = p1.distance(p2);"

method and variable declarations do nothing
anchor this to correct segment

translated into:
	"
	push argument 0
	pop pointer 0
	push this 0
	push argument 0
	call Point.getx 1
	sub
	pop local 0
	// dy statement is very similar
	push local 0
	push local 0
	call Math.multiply 2
	push local 1
	push local 1
	call Math.multiply 2
	add call Math.sqrt 1
	return

	"

void methods are similar to normal ones, but they always have to return a value
the dummy value is dumped in some place. sadly it can't be dumped into constant



Unit 5.8: Handling Arrays
Confusion cleaner activated! I didn't realize you had to pass in a size argument for arrays. It makes their compilation a lot easier.

THIS and THAT are "portable" because their starting address can be moved.
set THIS and THAT with pointer 0 and pointer 1

example for THIS and THAT manipulation
VM is extremely secure! it isn't even handling the RAM most of the time.

array access is a bit difficult because if there are multiple arrays being accessed, you can get a pointer overwriting error!
instead of pointer, use temp

example:
"a[i] = b[j]"

generated code:
"
push a
push i
add

push b
push j
add

pop pointer 1
push that 0
pop temp 0

pop pointer 1
push temp 0

pop that 0

"

arr[expression₁] = expression₂: expression₂ can use pointer 1 and that 0 safely

this solution also works for ginormous expressions like a[a[i]] = a[b[a[b[j]]]]



Unit 5.9: Standard Mapping Over the Virtual Machine

why is there a question at the very beginning of the video that nobody can get to?

just focus on Jack to VM, we handled everything below VM in the past

Standard mapping:
accessing array entries:
	set pointer 1 to the entry's address(arr + i)
	then access entry by accessing this 0
When compiling a Jack method:
	the compiled VM code must set the base of the THIS segment to argument 0
When compiling constructors:
	the compiled VM code must allocate a memory block for the new object, then set the base of the segment THIS to the new object's base address
	the compiled VM code must return the object's base address to the caller
When compiling a void function:
	the compiled VM code must return the value constant 0
When compiling a subroutine call subName(arg1, arg2, ...):
	the caller (a VM function) must push the arguments onto the stack, then call the subroutine
If the called subroutine is a method:
	the caller must first push a reference to the object on which the method is supposed to operate
	next, the caller must push arg1, arg2, ... and then call the method
If the called subroutine is void:
	A void subroutine does not return a value at the Jack level.
	However, at the VM level, it must return some dummy value.
	Therefore, when compiling the Jack statement do subName, following the call the caller must pop (and ignore) the returned value

Compiling constants:
	null is mapped on the constant 0
	false is mapped on the constant 0
	true is mapped on the constant -1 or push 1 followed by neg

The basic Jack OS is implemented as a set of compiled VM class files
All OS class files must reside in the same directory as the VM files generated by the compiler
Any VM function can call any OS VM function

Multiplication and division are handled with OS functions
String constants are created using the String OS constructor
String assignments like x="cc...c" are handled using a series of calls to String.appendChar(c)
Object construction requires allocating space for the new object using the OS function Memory.alloc(size)
Object recycling is handled using the OS function Memory.deAlloc(object)



Unit 5.10: Completing the Compiler: Proposed Implementation

main focus of project: SymbolTable and VMWriter

either compile a single file name or a directory
JackTokenizer: doesn't need to be touched
SymbolTable: only two are needed.

SymbolTable API:
	Constructor - Creates a new symbol table.

	startSubroutine - Resets subroutine symbol table

	define - Defines new identifier of given name, type, and kind, and assigns it a running index. STATIC/FIELD
	identifiers have class scope, others have only subroutine scope. All arguments: name -> String, type -> String,
	kind -> STATIC, FIELD, ARG, VAR.

	VarCount - Returns num of variables of the given kind. Returns an integer. Arguments: kind -> STATIC, FIELD, ARG, VAR.

	KindOf - Returns STATIC, FIELD, ARG, VAR, NONE. Arguments: name (String)

	TypeOf - Returns a string. Arguments: name.

	IndexOf - Returns an int (index assigned to named identifier). Args: name.

Can be implemented with two separate hash tables.
When we start compiling a new subroutine, the latter hash table can be reset.
When compiling error-free Jack code, each symbol not yet found in the symbol tables can be assumed to be either a
subroutine name or a class name.

VMWriter emits code to output VM file.

VMWriter API:
	Constructor - Creates new write-only output .vm file. Args: file/stream.

	writePush - Writes "push" + segment + index. Args: segment, index.

	writePop - Writes "pop" + segment + index. Args: segment, index.

	writeArithmetic - writes an arithmetic command. Args: command.

	writeLabel - writes a label command.

	writeGoto - writes a goto command.

	writeIf - writes an if-goto command.

	writeCall - writes a call command.

	writeFunction - writes a function command.

	writeReturn - writes "return".

	close - closes the output file.


this is just an encapsulation.


CompilationEngine overview:
	gets input from a jack tokenizer and writes output using the VM writer

	Contract:
		Each compile routine should read from the input, advance, then emit with VMWriter
		compileXXX should only be called if XXX is the current syntactic element
		If XXX is part of an expression and has a value, emitted VM code should compute the value and leave it at the top of the VM's stack

CompilationEngine implementation notes:
	The CompilationEngine API is identical to the CompilationEngine API is the same as the one in the Syntax Analyzer!
	Start with SyntaxAnalyzer, morph it into full scale compiler

the next unit is about guidelines for this module.



Unit 5.11: Project 11

Project 11 is just for extending the syntax analyzer into a full-scale compiler
Stage 0 is syntax analyzer, stage 1 is symbol table handling
stage 2 is the actual code generation

Stage 1: the output of an identifier is just identifier. We can change that.

SymbolTable testing plan:
	Implementation: implement it then extend syntax analyzer with identifier handling above
This allows the symbol table to be unit-tested with project 10 test cases

Project 11 gives test programs (six in fact)

test evolving compiler on supplied test programs in the shown order:
	Seven
	ConvertToBin
	Square
	Average
	Pong
	ComplexArrays

use compiler to compile the program directory


For each test program:
	1. Use compiler to compile program directory
	2. Check generated code, fix compiler and go back to test & stage 1 as needed
	3. Load directory into VM emulator
	4. Run the compiled program, inspect results
	5. If there's a problem, fix compiler and go back to stage 1

the only difference in the mindset of the testing is that the compiler is incorrect when the code breaks, not the code!

Test program: Seven
	Tests how your compiler handles class, do, return, and simple arithmetic
	output should look something like this:
		"
		function Main.main 0
		push constant 1
		push constant 2
		push constant 3
		call Math.multiply 2
		add
		call Output.printInt 1
		pop temp 0
		push constant 0
		return

		"

	you must see 7 in the top-left corner of the screen


Test program: decimal-to-binary conversion
	tests how your compile handles expressions and procedural constructs

Test app: Square
	Tests constructors, methods, and expressions that include method calls

Test program: average
	Tests how your compiler handles arrays and strings

Test app: Pong
	Tests how your compiler handles a complete object-oriented application, including the handling of objects and static variables.

Test program: ComplexArrays
	Tests how your compiler handles long, hairy array manipulation.



Unit 5.12: Perspective

Question 1: Jack is relatively simple, how to generate complex language code?
	there are few types in Jack but there are a lot in complex languages
	there is also no inheritance or global variables
Question 2: How difficult would it be to close the gaps between Java and Jack?
	actually it's quite difficult
Question 3: What does compiler optimization mean?
	it's not about making the compiler efficient. It's that VM code generation is optimized.
